{"version":3,"file":"932.bundle.js","mappings":"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","sources":["webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/version.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/lib/push.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js","webpack://capstone-project/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["export const version = '2.9.5';\n//# sourceMappingURL=version.js.map","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` };\nexport const VSN = '1.0.0';\nexport const DEFAULT_TIMEOUT = 10000;\nexport const WS_CLOSE_NORMAL = 1000;\nexport var SOCKET_STATES;\n(function (SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nexport var CHANNEL_STATES;\n(function (CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nexport var CHANNEL_EVENTS;\n(function (CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nexport var TRANSPORTS;\n(function (TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nexport var CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n//# sourceMappingURL=constants.js.map","/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\nexport var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function (REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nexport default class RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */\n    constructor(channel, opts) {\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.caller = {\n            onJoin: () => { },\n            onLeave: () => { },\n            onSync: () => { },\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: 'presence_state',\n            diff: 'presence_diff',\n        };\n        this.channel._on(events.state, {}, (newState) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff) => {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            }\n            else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences) => {\n            this.channel._trigger('presence', {\n                event: 'join',\n                key,\n                currentPresences,\n                newPresences,\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences) => {\n            this.channel._trigger('presence', {\n                event: 'leave',\n                key,\n                currentPresences,\n                leftPresences,\n            });\n        });\n        this.onSync(() => {\n            this.channel._trigger('presence', { event: 'sync' });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */\n    static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences) => {\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences) => {\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n                const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            }\n            else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */\n    static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves),\n        };\n        if (!onJoin) {\n            onJoin = () => { };\n        }\n        if (!onLeave) {\n            onLeave = () => { };\n        }\n        this.map(joins, (key, newPresences) => {\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n                const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences) => {\n            let currentPresences = state[key];\n            if (!currentPresences)\n                return;\n            const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n            currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0)\n                delete state[key];\n        });\n        return state;\n    }\n    /** @internal */\n    static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */\n    static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n            const presences = state[key];\n            if ('metas' in presences) {\n                newState[key] = presences.metas.map((presence) => {\n                    presence['presence_ref'] = presence['phx_ref'];\n                    delete presence['phx_ref'];\n                    delete presence['phx_ref_prev'];\n                    return presence;\n                });\n            }\n            else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */\n    static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */\n    onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */\n    onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */\n    onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */\n    inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n}\n//# sourceMappingURL=RealtimePresence.js.map","/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nexport const toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nexport const toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexport const toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\n//# sourceMappingURL=transformers.js.map","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n//# sourceMappingURL=timer.js.map","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nexport default class Serializer {\n    constructor() {\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === 'string') {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return { ref: null, topic: topic, event: event, payload: data };\n    }\n}\n//# sourceMappingURL=serializer.js.map","import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nimport RealtimePresence from './RealtimePresence';\nimport * as Transformers from './lib/transformers';\nexport var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nexport var REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    /**\n     * listen to Postgres changes.\n     */\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nexport var REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '' },\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new RealtimePresence(this);\n        this.broadcastEndpointURL = this._broadcastEndpointURL();\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            const { config: { broadcast, presence }, } = this.params;\n            this._onError((e) => callback && callback('CHANNEL_ERROR', e));\n            this._onClose(() => callback && callback('CLOSED'));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [],\n            };\n            if (this.socket.accessToken) {\n                accessTokenPayload.access_token = this.socket.accessToken;\n            }\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', ({ postgres_changes: serverPostgresFilters, }) => {\n                var _a;\n                this.socket.accessToken &&\n                    this.socket.setAuth(this.socket.accessToken);\n                if (serverPostgresFilters === undefined) {\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = serverPostgresFilters && serverPostgresFilters[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            callback &&\n                                callback('CHANNEL_ERROR', new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback('SUBSCRIBED');\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                callback &&\n                    callback('CHANNEL_ERROR', new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback && callback('TIMED_OUT');\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const options = {\n                method: 'POST',\n                headers: {\n                    apikey: (_a = this.socket.apiKey) !== null && _a !== void 0 ? _a : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        { topic: this.subTopic, event, payload: endpoint_payload },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_b = opts.timeout) !== null && _b !== void 0 ? _b : this.timeout);\n                if (response.ok) {\n                    return 'ok';\n                }\n                else {\n                    return 'error';\n                }\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve) => {\n            const leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        });\n    }\n    /** @internal */\n    _broadcastEndpointURL() {\n        let url = this.socket.endPoint;\n        url = url.replace(/^ws/i, 'http');\n        url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n        return url.replace(/\\/+$/, '') + '/api/broadcast';\n    }\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return (((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' ||\n                    ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower);\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) ===\n                                    ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return (bindEvent === '*' ||\n                            bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase()));\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map","import { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessToken = null;\n        this.apiKey = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                _fetch = (...args) => import('@supabase/node-fetch').then(({ default: fetch }) => fetch(...args));\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.transport) {\n            this.transport = options.transport;\n        }\n        else {\n            this.transport = null;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const accessToken = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n        if (accessToken) {\n            this.accessToken = accessToken;\n            this.apiKey = accessToken;\n        }\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(async () => {\n            this.disconnect();\n            this.connect();\n        }, this.reconnectAfterMs);\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        if (this.transport) {\n            this.conn = new this.transport(this._endPointURL(), undefined, {\n                headers: this.headers,\n            });\n            return;\n        }\n        if (NATIVE_WEBSOCKET_AVAILABLE) {\n            this.conn = new WebSocket(this._endPointURL());\n            this.setupConnection();\n            return;\n        }\n        this.conn = new WSWebSocketDummy(this._endPointURL(), undefined, {\n            close: () => {\n                this.conn = null;\n            },\n        });\n        import('ws').then(({ default: WS }) => {\n            this.conn = new WS(this._endPointURL(), undefined, {\n                headers: this.headers,\n            });\n            this.setupConnection();\n        });\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ access_token: token });\n            if (channel.joinedOnce && channel._isJoined()) {\n                channel._push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */\n    setupConnection() {\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n    _endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this._endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    /** @internal */\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /** @internal */\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n}\nclass WSWebSocketDummy {\n    constructor(address, _protocols, options) {\n        this.binaryType = 'arraybuffer';\n        this.onclose = () => { };\n        this.onerror = () => { };\n        this.onmessage = () => { };\n        this.onopen = () => { };\n        this.readyState = SOCKET_STATES.connecting;\n        this.send = () => { };\n        this.url = null;\n        this.url = address;\n        this.close = options.close;\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map"],"names":["DEFAULT_HEADERS","SOCKET_STATES","CHANNEL_EVENTS","TRANSPORTS","CONNECTION_STATE","REALTIME_PRESENCE_LISTEN_EVENTS","PostgresTypes","CHANNEL_STATES","Timer","constructor","callback","timerCalc","this","timer","undefined","tries","reset","clearTimeout","scheduleTimeout","setTimeout","Serializer","HEADER_LENGTH","decode","rawPayload","ArrayBuffer","_binaryDecode","JSON","parse","buffer","view","DataView","decoder","TextDecoder","_decodeBroadcast","topicSize","getUint8","eventSize","offset","topic","slice","event","ref","payload","byteLength","Push","channel","timeout","sent","timeoutTimer","receivedResp","recHooks","refEvent","resend","_cancelRefEvent","send","_hasReceived","startTimeout","socket","push","join_ref","_joinRef","updatePayload","Object","assign","receive","status","_a","response","_makeRef","_replyEventName","_on","_cancelTimeout","_matchReceive","trigger","_trigger","destroy","_off","filter","h","forEach","RealtimePresence","opts","state","pendingDiffs","joinRef","caller","onJoin","onLeave","onSync","events","diff","newState","syncState","syncDiff","inPendingSyncState","key","currentPresences","newPresences","leftPresences","currentState","cloneDeep","transformedState","transformState","joins","leaves","map","presences","newPresenceRefs","m","presence_ref","curPresenceRefs","joinedPresences","indexOf","length","joinedPresenceRefs","curPresences","unshift","presenceRefsToRemove","obj","func","getOwnPropertyNames","reduce","metas","presence","stringify","convertChangeData","columns","record","options","skipTypes","keys","acc","rec_key","convertColumn","columnName","column","find","x","name","colType","type","value","includes","convertCell","noop","charAt","dataType","toArray","bool","toBoolean","float4","float8","int2","int4","int8","numeric","oid","toNumber","json","jsonb","toJson","timestamp","toTimestampString","abstime","date","daterange","int4range","int8range","money","reltime","text","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","Number","isNaN","error","console","log","lastIdx","closeBrace","arr","valTrim","_","split","val","replace","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","RealtimeChannel","params","config","bindings","closed","joinedOnce","pushBuffer","subTopic","broadcast","ack","self","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","joined","pushEvent","_onClose","_remove","_onError","reason","_isLeaving","_isClosed","errored","_isJoining","reply","broadcastEndpointURL","_broadcastEndpointURL","subscribe","_b","isConnected","connect","e","accessTokenPayload","postgres_changes","r","accessToken","access_token","updateJoinPayload","_rejoin","serverPostgresFilters","setAuth","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","schema","table","serverPostgresFilter","unsubscribe","Error","id","values","presenceState","track","untrack","on","args","_canPush","Promise","resolve","_c","_push","endpoint_payload","method","headers","apikey","apiKey","body","messages","_fetchWithTimeout","ok","leaving","onClose","close","leavePush","leave","url","endPoint","controller","AbortController","abort","fetch","signal","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","handledPayload","bind","_d","_e","_f","bindId","bindEvent","ids","data","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","isEqual","obj1","obj2","k","_leaveOpenTopic","records","old_record","NATIVE_WEBSOCKET_AVAILABLE","WebSocket","RealtimeClient","channels","heartbeatIntervalMs","heartbeatTimer","pendingHeartbeatRef","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","message","_resolveFetch","customFetch","_fetch","then","default","websocket","transport","encode","reconnectTimer","async","disconnect","_endPointURL","setupConnection","WSWebSocketDummy","WS","code","onclose","clearInterval","getChannels","removeChannel","removeAllChannels","values_1","all","kind","msg","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","chan","result","token","newRef","toString","dupChannel","c","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","_appendParams","vsn","rawMessage","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","prefix","match","URLSearchParams","address","_protocols"],"sourceRoot":""}