{"version":3,"file":"75.bundle.js","mappings":"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","sources":["webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/lib/errors.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/lib/version.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/lib/constants.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js","webpack://capstone-project/./node_modules/@supabase/storage-js/dist/module/StorageClient.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js","webpack://capstone-project/./node_modules/@supabase/supabase-js/dist/module/index.js"],"sourcesContent":["export class StorageError extends Error {\n    constructor(message) {\n        super(message);\n        this.__isStorageError = true;\n        this.name = 'StorageError';\n    }\n}\nexport function isStorageError(error) {\n    return typeof error === 'object' && error !== null && '__isStorageError' in error;\n}\nexport class StorageApiError extends StorageError {\n    constructor(message, status) {\n        super(message);\n        this.name = 'StorageApiError';\n        this.status = status;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n        };\n    }\n}\nexport class StorageUnknownError extends StorageError {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'StorageUnknownError';\n        this.originalError = originalError;\n    }\n}\n//# sourceMappingURL=errors.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => import('@supabase/node-fetch').then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (typeof Response === 'undefined') {\n        // @ts-ignore\n        return (yield import('@supabase/node-fetch')).Response;\n    }\n    return Response;\n});\n//# sourceMappingURL=helpers.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { StorageApiError, StorageUnknownError } from './errors';\nimport { resolveResponse } from './helpers';\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject) => __awaiter(void 0, void 0, void 0, function* () {\n    const Res = yield resolveResponse();\n    if (error instanceof Res) {\n        error\n            .json()\n            .then((err) => {\n            reject(new StorageApiError(_getErrorMessage(err), error.status || 500));\n        })\n            .catch((err) => {\n            reject(new StorageUnknownError(_getErrorMessage(err), err));\n        });\n    }\n    else {\n        reject(new StorageUnknownError(_getErrorMessage(error), error));\n    }\n});\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            fetcher(url, _getRequestParams(method, options, parameters, body))\n                .then((result) => {\n                if (!result.ok)\n                    throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n                    return result;\n                return result.json();\n            })\n                .then((data) => resolve(data))\n                .catch((error) => handleError(error, reject));\n        });\n    });\n}\nexport function get(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'GET', url, options, parameters);\n    });\n}\nexport function post(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'POST', url, options, parameters, body);\n    });\n}\nexport function put(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'PUT', url, options, parameters, body);\n    });\n}\nexport function remove(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n    });\n}\n//# sourceMappingURL=fetch.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { isStorageError, StorageError } from '../lib/errors';\nimport { get, post, remove } from '../lib/fetch';\nimport { resolveFetch } from '../lib/helpers';\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc',\n    },\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false,\n};\nexport default class StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch) {\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), (method === 'POST' && { 'x-upsert': String(options.upsert) }));\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({ method, body: body, headers }, ((options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {})));\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n                        error: null,\n                    };\n                }\n                else {\n                    const error = data;\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cleanPath = this._removeEmptyFolders(path);\n            const _path = this._getFinalPath(cleanPath);\n            const url = new URL(this.url + `/object/upload/sign/${_path}`);\n            url.searchParams.set('token', token);\n            try {\n                let body;\n                const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), { 'x-upsert': String(options.upsert) });\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const res = yield this.fetch(url.toString(), {\n                    method: 'PUT',\n                    body: body,\n                    headers,\n                });\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: { path: cleanPath, fullPath: data.Key },\n                        error: null,\n                    };\n                }\n                else {\n                    const error = data;\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */\n    createSignedUploadUrl(path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                const headers = Object.assign({}, this.headers);\n                if (options === null || options === void 0 ? void 0 : options.upsert) {\n                    headers['x-upsert'] = 'true';\n                }\n                const data = yield post(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });\n                const url = new URL(this.url + data.url);\n                const token = url.searchParams.get('token');\n                if (!token) {\n                    throw new StorageError('No token returned by API');\n                }\n                return { data: { signedUrl: url.toString(), path, token }, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */\n    move(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */\n    copy(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data: { path: data.Key }, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    createSignedUrl(path, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, ((options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {})), { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n                data = { signedUrl };\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */\n    createSignedUrls(paths, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                return {\n                    data: data.map((datum) => (Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL\n                            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n                            : null }))),\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    download(path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n            const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';\n            const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n            const queryString = transformationQuery ? `?${transformationQuery}` : '';\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                    headers: this.headers,\n                    noResolveJson: true,\n                });\n                const data = yield res.blob();\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n            ? `download=${options.download === true ? '' : options.download}`\n            : '';\n        if (downloadQueryParam !== '') {\n            _queryString.push(downloadQueryParam);\n        }\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n        const renderPath = wantsTransformation ? 'render/image' : 'object';\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== '') {\n            _queryString.push(transformationQuery);\n        }\n        let queryString = _queryString.join('&');\n        if (queryString !== '') {\n            queryString = `?${queryString}`;\n        }\n        return {\n            data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n        };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */\n    remove(paths) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     */\n    list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });\n                const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) {\n            params.push(`width=${transform.width}`);\n        }\n        if (transform.height) {\n            params.push(`height=${transform.height}`);\n        }\n        if (transform.resize) {\n            params.push(`resize=${transform.resize}`);\n        }\n        if (transform.format) {\n            params.push(`format=${transform.format}`);\n        }\n        if (transform.quality) {\n            params.push(`quality=${transform.quality}`);\n        }\n        return params.join('&');\n    }\n}\n//# sourceMappingURL=StorageFileApi.js.map","// generated by genversion\nexport const version = '2.6.0';\n//# sourceMappingURL=version.js.map","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` };\n//# sourceMappingURL=constants.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_HEADERS } from '../lib/constants';\nimport { isStorageError } from '../lib/errors';\nimport { get, post, put, remove } from '../lib/fetch';\nimport { resolveFetch } from '../lib/helpers';\nexport default class StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */\n    listBuckets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n    getBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     */\n    createBucket(id, options = {\n        public: false,\n    }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */\n    updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n    emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n    deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (isStorageError(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=StorageBucketApi.js.map","import StorageFileApi from './packages/StorageFileApi';\nimport StorageBucketApi from './packages/StorageBucketApi';\nexport class StorageClient extends StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        super(url, headers, fetch);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */\n    from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n}\n//# sourceMappingURL=StorageClient.js.map","import { version } from './version';\nlet JS_ENV = '';\n// @ts-ignore\nif (typeof Deno !== 'undefined') {\n    JS_ENV = 'deno';\n}\nelse if (typeof document !== 'undefined') {\n    JS_ENV = 'web';\n}\nelse if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    JS_ENV = 'react-native';\n}\nelse {\n    JS_ENV = 'node';\n}\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js-${JS_ENV}/${version}` };\nexport const DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS,\n};\nexport const DEFAULT_DB_OPTIONS = {\n    schema: 'public',\n};\nexport const DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: 'implicit',\n};\nexport const DEFAULT_REALTIME_OPTIONS = {};\n//# sourceMappingURL=constants.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\nimport nodeFetch, { Headers as NodeFetchHeaders } from '@supabase/node-fetch';\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = nodeFetch;\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nexport const resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return NodeFetchHeaders;\n    }\n    return Headers;\n};\nexport const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map","import { AuthClient } from '@supabase/auth-js';\nexport class SupabaseAuthClient extends AuthClient {\n    constructor(options) {\n        super(options);\n    }\n}\n//# sourceMappingURL=SupabaseAuthClient.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient, } from '@supabase/postgrest-js';\nimport { RealtimeClient, } from '@supabase/realtime-js';\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js';\nimport { DEFAULT_GLOBAL_OPTIONS, DEFAULT_DB_OPTIONS, DEFAULT_AUTH_OPTIONS, DEFAULT_REALTIME_OPTIONS, } from './lib/constants';\nimport { fetchWithAuth } from './lib/fetch';\nimport { stripTrailingSlash, applySettingDefaults } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.global.fetch A custom fetch implementation.\n     * @param options.global.headers Any additional headers to send with each network request.\n     */\n    constructor(supabaseUrl, supabaseKey, options) {\n        var _a, _b, _c;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl)\n            throw new Error('supabaseUrl is required.');\n        if (!supabaseKey)\n            throw new Error('supabaseKey is required.');\n        const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        // default storage key uses the supabase project ref as a namespace\n        const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),\n            global: DEFAULT_GLOBAL_OPTIONS,\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n        this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));\n        this.rest = new PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch,\n        });\n        this._listenForAuthEvents();\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */\n    get functions() {\n        return new FunctionsClient(this.functionsUrl, {\n            headers: this.headers,\n            customFetch: this.fetch,\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */\n    get storage() {\n        return new SupabaseStorageClient(this.storageUrl, this.headers, this.fetch);\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        return this.rest.from(relation);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.schema\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n    schema(schema) {\n        return this.rest.schema(schema);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, options = {}) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n     *\n     * @param {string} name - The name of the Realtime channel.\n     * @param {Object} opts - The options to pass to the Realtime channel.\n     *\n     */\n    channel(name, opts = { config: {} }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n     * Returns all Realtime channels.\n     */\n    getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n     * Unsubscribes and removes Realtime channel from Realtime client.\n     *\n     * @param {RealtimeChannel} channel - The name of the Realtime channel.\n     *\n     */\n    removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n     * Unsubscribes and removes all Realtime channels from Realtime client.\n     */\n    removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    _getAccessToken() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { data } = yield this.auth.getSession();\n            return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n        });\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, debug, }, headers, fetch) {\n        var _a;\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`,\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, authHeaders), headers),\n            storageKey: storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            flowType,\n            debug,\n            fetch,\n            // auth checks if there is a custom authorizaiton header using this flag\n            // so it knows whether to return an error when getUser is called with no session\n            hasCustomAuthorizationHeader: (_a = 'Authorization' in this.headers) !== null && _a !== void 0 ? _a : false,\n        });\n    }\n    _initRealtimeClient(options) {\n        return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));\n    }\n    _listenForAuthEvents() {\n        let data = this.auth.onAuthStateChange((event, session) => {\n            this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n        });\n        return data;\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n            this.changedAccessToken !== token) {\n            // Token has changed\n            this.realtime.setAuth(token !== null && token !== void 0 ? token : null);\n            this.changedAccessToken = token;\n        }\n        else if (event === 'SIGNED_OUT') {\n            // Token is removed\n            this.realtime.setAuth(this.supabaseKey);\n            if (source == 'STORAGE')\n                this.auth.signOut();\n            this.changedAccessToken = undefined;\n        }\n    }\n}\n//# sourceMappingURL=SupabaseClient.js.map","export function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexport function stripTrailingSlash(url) {\n    return url.replace(/\\/$/, '');\n}\nexport const isBrowser = () => typeof window !== 'undefined';\nexport function applySettingDefaults(options, defaults) {\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions, } = options;\n    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS, } = defaults;\n    return {\n        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),\n        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),\n        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),\n        global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions),\n    };\n}\n//# sourceMappingURL=helpers.js.map","import SupabaseClient from './SupabaseClient';\nexport * from '@supabase/auth-js';\nexport { FunctionsHttpError, FunctionsFetchError, FunctionsRelayError, FunctionsError, FunctionRegion, } from '@supabase/functions-js';\nexport * from '@supabase/realtime-js';\nexport { default as SupabaseClient } from './SupabaseClient';\n/**\n * Creates a new Supabase Client.\n */\nexport const createClient = (supabaseUrl, supabaseKey, options) => {\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\n//# sourceMappingURL=index.js.map"],"names":["StorageError","Error","constructor","message","super","this","__isStorageError","name","isStorageError","error","StorageApiError","status","toJSON","StorageUnknownError","originalError","resolveFetch","customFetch","_fetch","fetch","args","then","default","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","apply","_getErrorMessage","err","msg","error_description","JSON","stringify","handleError","Res","Response","json","catch","_getRequestParams","method","options","parameters","body","params","headers","Object","assign","_handleRequest","fetcher","url","ok","noResolveJson","data","get","post","remove","DEFAULT_SEARCH_OPTIONS","limit","offset","sortBy","column","order","DEFAULT_FILE_OPTIONS","cacheControl","contentType","upsert","StorageFileApi","bucketId","uploadOrUpdate","path","fileBody","fileOptions","String","Blob","FormData","append","cleanPath","_removeEmptyFolders","_path","_getFinalPath","res","duplex","id","Id","fullPath","Key","upload","uploadToSignedUrl","token","URL","searchParams","set","toString","createSignedUploadUrl","signedUrl","update","move","fromPath","toPath","sourceKey","destinationKey","destinationBucket","copy","createSignedUrl","expiresIn","transform","downloadQueryParam","download","encodeURI","signedURL","createSignedUrls","paths","map","datum","renderPath","transformationQuery","transformOptsToQueryString","queryString","blob","getPublicUrl","_queryString","push","join","publicUrl","prefixes","list","prefix","replace","width","height","resize","format","quality","DEFAULT_HEADERS","StorageBucketApi","listBuckets","getBucket","createBucket","public","file_size_limit","fileSizeLimit","allowed_mime_types","allowedMimeTypes","updateBucket","put","emptyBucket","deleteBucket","StorageClient","from","JS_ENV","Deno","document","navigator","product","DEFAULT_GLOBAL_OPTIONS","DEFAULT_DB_OPTIONS","schema","DEFAULT_AUTH_OPTIONS","autoRefreshToken","persistSession","detectSessionInUrl","flowType","DEFAULT_REALTIME_OPTIONS","fetchWithAuth","supabaseKey","getAccessToken","HeadersConstructor","Headers","input","init","_a","accessToken","has","SupabaseAuthClient","SupabaseClient","supabaseUrl","_b","_c","_supabaseUrl","realtimeUrl","authUrl","storageUrl","functionsUrl","defaultStorageKey","hostname","split","settings","defaults","db","dbOptions","auth","authOptions","realtime","realtimeOptions","global","globalOptions","applySettingDefaults","storageKey","_initSupabaseAuthClient","_getAccessToken","bind","_initRealtimeClient","rest","_listenForAuthEvents","functions","FunctionsClient","F","storage","relation","rpc","fn","channel","opts","config","getChannels","removeChannel","removeAllChannels","getSession","session","access_token","debug","authHeaders","Authorization","apikey","hasCustomAuthorizationHeader","onAuthStateChange","event","_handleTokenChanged","source","changedAccessToken","setAuth","signOut","undefined","createClient"],"sourceRoot":""}